<body
  style="
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    display: flex;
    gap: 2rem;
  "
>
  <pre id="game1" style="max-width: 50%"></pre>
  <!-- <pre id="game2" style="flex: 1"></pre> -->
  <pre id="log" style="max-width: 50%"></pre>
  <!-- <pre id="game2"></pre> -->
</body>

<script>
  let boardCols = 10;
  let boardRows = 10;
  let moves = [
    {
      r: 5,
      c: 5,
      dir: "east",
      tick: 1,
    },
  ]; // { r,c, direction, nTick }[]
  let headPosition = { r: 5, c: 5 };
  let nTick = 1;
  let nLength = 2;

  let tailWipeQueue = [];

  /**
   * 0 = empty
   * 1 = head
   * 2 = tail
   * 3 = food
   */
  let board = new Array(boardCols)
    .fill(null)
    .map(() => new Array(boardRows).fill(0));

  const game1 = document.getElementById("game1");

  const COLOR_MAP = {
    0: "‚¨úÔ∏è",
    1: "üü¶",
    2: "üü©",
    3: "üçé",
    4: "üü•",
  };

  function drawBoard() {
    let html = "";
    for (let r = 0; r < boardRows; r++) {
      html += "";
      for (let c = 0; c < boardCols; c++) {
        html += ` ${COLOR_MAP[board[r][c]]}</td>`;
      }
      html += "\n";
    }
    html += "\n";
    html += `tick: ${nTick}\n`;
    html += `length: ${nLength}\n`;
    html += JSON.stringify(tailWipeQueue);
    html += "\n";
    html += moves
      .slice()
      .reverse()
      .map((m) => JSON.stringify(m))
      .join("\n");
    game1.innerHTML = html;
  }

  function endGame() {
    clearInterval(tickLoop);
    alert("Game over!");
  }

  function tick() {
    let currentDir = moves[moves.length - 1].dir;

    board[headPosition.r][headPosition.c] = 2;
    tailWipeQueue.push({ ...headPosition });

    let newHeadPosition = { ...headPosition };

    if (currentDir === "north") {
      newHeadPosition.r -= 1;
    } else if (currentDir === "south") {
      newHeadPosition.r += 1;
    } else if (currentDir === "east") {
      newHeadPosition.c += 1;
    } else if (currentDir === "west") {
      newHeadPosition.c -= 1;
    }

    const isEdge =
      newHeadPosition.r < 0 ||
      newHeadPosition.r >= boardRows ||
      newHeadPosition.c < 0 ||
      newHeadPosition.c >= boardCols;

    const isCollision =
      board[newHeadPosition.r][newHeadPosition.c] === 1 ||
      board[newHeadPosition.r][newHeadPosition.c] === 2;

    if (isEdge) {
      board[headPosition.r][headPosition.c] = 4;
      drawBoard();
      setTimeout(endGame, 200);
      return;
    }
    if (isCollision) {
      board[newHeadPosition.r][newHeadPosition.c] = 4;
      drawBoard();
      setTimeout(endGame, 200);
      return;
    }

    headPosition = newHeadPosition;

    const isEating = board[headPosition.r][headPosition.c] === 3;

    board[headPosition.r][headPosition.c] = 1;

    if (!isEating && nTick > 2) {
      let resetCoords = tailWipeQueue.shift();
      if (resetCoords) {
        board[resetCoords.r][resetCoords.c] = 0;
      }
    }

    if (nTick % 10 === 0) {
      // spawn food
      let success = false;
      do {
        const r = Math.floor(Math.random() * boardRows);
        const c = Math.floor(Math.random() * boardCols);
        if (board[r][c] === 0) {
          board[r][c] = 3;
          success = true;
        }
      } while (!success);
    }

    drawBoard();
    nTick++;
  }

  const dirMap = {
    ArrowUp: "north",
    ArrowDown: "south",
    ArrowLeft: "west",
    ArrowRight: "east",
  };

  addEventListener("keydown", (e) => {
    if (e.key in dirMap) {
      const lastMove = moves[moves.length - 1];
      if (lastMove.tick === nTick) {
        return;
      }

      const currentDir = lastMove.dir;

      const newDir = dirMap[e.key];
      if (currentDir === newDir) {
        return;
      }

      const is180 =
        (currentDir === "north" && newDir === "south") ||
        (currentDir === "south" && newDir === "north") ||
        (currentDir === "east" && newDir === "west") ||
        (currentDir === "west" && newDir === "east");
      if (is180) {
        return;
      }

      const newMove = {
        r: headPosition.r,
        c: headPosition.c,
        dir: dirMap[e.key],
        tick: nTick,
      };
      moves.push(newMove);
      conn.send(JSON.stringify(newMove));
    }
  });
  const tickLoop = setInterval(tick, 550);

  var conn;
  var log = document.getElementById("log");

  function appendLog(item) {
    var doScroll = log.scrollTop > log.scrollHeight - log.clientHeight - 1;
    log.appendChild(item);
    if (doScroll) {
      log.scrollTop = log.scrollHeight - log.clientHeight;
    }
  }

  if (window["WebSocket"]) {
    conn = new WebSocket("ws://" + document.location.host + "/ws");
    conn.onclose = function (evt) {
      var item = document.createElement("div");
      item.innerHTML = "<b>Connection closed.</b>";
      appendLog(item);
    };
    conn.onmessage = function (evt) {
      var messages = evt.data.split("\n");
      for (var i = 0; i < messages.length; i++) {
        var item = document.createElement("div");
        item.innerText = messages[i];
        appendLog(item);
      }
    };
  } else {
    var item = document.createElement("div");
    item.innerHTML = "<b>Your browser does not support WebSockets.</b>";
    appendLog(item);
  }
</script>
