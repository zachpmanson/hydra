<style>
  .pulse {
    animation: pulse 2s infinite;
  }
  @keyframes pulse {
    50% {
      opacity: 0.5;
    }
  }
</style>
<body
  style="
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    display: flex;
    gap: 2rem;
  "
>
  <pre id="game1" style="max-width: 50%"></pre>
  <!-- <pre id="game2" style="flex: 1"></pre> -->
  <pre id="log" style="max-width: 50%"></pre>
  <!-- <pre id="game2"></pre> -->
</body>

<script>
  class GameState {
    constructor({ board, moves, headPosition, nLength, tailWipeQueue }) {
      this.board = board;
      this.moves = moves;
      this.headPosition = headPosition;
      this.nLength = nLength;
      this.tailWipeQueue = tailWipeQueue;
    }
  }

  let boardCols = 20;
  let boardRows = 10;

  let state1 = new GameState({
    board: new Array(boardRows)
      .fill(null)
      .map(() => new Array(boardCols).fill(0)),
    moves: [
      {
        r: 5,
        c: 5,
        dir: "east",
        tick: 1,
      },
    ],
    nLength: 2,
    tailWipeQueue: [],
    headPosition: { r: 5, c: 5 },
  });

  let foodDrops = [];
  let nTick = 1;
  let nLength = 2;

  /**
   * 0 = empty
   * 1 = head
   * 2 = tail
   * 3 = food
   */

  let board2 = new Array(boardCols)
    .fill(null)
    .map(() => new Array(boardRows).fill(0));

  const game1 = document.getElementById("game1");

  const COLOR_MAP = {
    0: "‚¨úÔ∏è",
    1: "<span class='pulse'>üü¶</span>",
    2: "üü©",
    3: "<span class='pulse'>üçé</span>",
    4: "üü•",
  };

  function drawBoard(boardNum = 1) {
    // const board = boardNum === 1 ? state1.board : board2;
    const board = state1.board;
    let html = "";
    for (let r = 0; r < boardRows; r++) {
      html += "";
      for (let c = 0; c < boardCols; c++) {
        html += ` ${COLOR_MAP[board[r][c]]}</td>`;
      }
      html += "\n";
    }
    html += "\n";
    html += `tick: ${nTick}\n`;
    html += `rows: ${boardRows} cols: ${boardCols}\n`;
    html += `length: ${nLength}\n`;
    html += `head: ${JSON.stringify(state1.headPosition)}\n`;
    // html += JSON.stringify(tailWipeQueue);
    html += "\n";
    html += state1.moves
      .slice()
      .reverse()
      .map((m) => JSON.stringify(m))
      .join("\n");

    game1.innerHTML = html;
    // (boardNum === 1 ? game1 : game2).innerHTML = html;
  }

  function endGame() {
    clearInterval(tickLoop);
    alert("Game over!");
  }

  function immutableTick(boardstate, tickNum, moveset, tailQueue) {}

  function tick(state) {
    let currentDir = state1.moves[state1.moves.length - 1].dir;

    state.board[state.headPosition.r][state.headPosition.c] = 2;
    state.tailWipeQueue.push({ ...state.headPosition });

    let newHeadPosition = { ...state.headPosition };

    if (currentDir === "north") {
      newHeadPosition.r -= 1;
    } else if (currentDir === "south") {
      newHeadPosition.r += 1;
    } else if (currentDir === "east") {
      newHeadPosition.c += 1;
    } else if (currentDir === "west") {
      newHeadPosition.c -= 1;
    }

    const isEdge =
      newHeadPosition.r < 0 ||
      newHeadPosition.r >= boardRows ||
      newHeadPosition.c < 0 ||
      newHeadPosition.c >= boardCols;

    if (isEdge) {
      state.board[state.headPosition.r][state.headPosition.c] = 4;
      drawBoard();
      setTimeout(endGame, 200);
      return;
    }

    const isCollision =
      state.board[newHeadPosition.r][newHeadPosition.c] === 1 ||
      state.board[newHeadPosition.r][newHeadPosition.c] === 2;
    if (isCollision) {
      state.board[newHeadPosition.r][newHeadPosition.c] = 4;
      drawBoard();
      setTimeout(endGame, 200);
      return;
    }

    state.headPosition = newHeadPosition;

    const isEating =
      state.board[state.headPosition.r][state.headPosition.c] === 3;

    state.board[state.headPosition.r][state.headPosition.c] = 1;

    if (!isEating && nTick > 2) {
      let resetCoords = state.tailWipeQueue.shift();
      if (resetCoords) {
        state.board[resetCoords.r][resetCoords.c] = 0;
      }
    }

    if (nTick % 10 === 0) {
      // spawn food
      let success = false;
      do {
        const r = Math.floor(Math.random() * boardRows);
        const c = Math.floor(Math.random() * boardCols);
        if (state.board[r][c] === 0) {
          state.board[r][c] = 3;
          foodDrops.push({
            r,
            c,
            tick: nTick,
          });
          success = true;
        }
      } while (!success);
    }

    drawBoard();
    nTick++;
  }

  const dirMap = {
    ArrowUp: "north",
    ArrowDown: "south",
    ArrowLeft: "west",
    ArrowRight: "east",
  };

  addEventListener("keydown", (e) => {
    if (e.key in dirMap) {
      const lastMove = state1.moves[state1.moves.length - 1];
      if (lastMove.tick === nTick) {
        return;
      }

      const currentDir = lastMove.dir;

      const newDir = dirMap[e.key];
      if (currentDir === newDir) {
        return;
      }

      const is180 =
        (currentDir === "north" && newDir === "south") ||
        (currentDir === "south" && newDir === "north") ||
        (currentDir === "east" && newDir === "west") ||
        (currentDir === "west" && newDir === "east");
      if (is180) {
        return;
      }

      const newMove = {
        r: state1.headPosition.r,
        c: state1.headPosition.c,
        dir: dirMap[e.key],
        tick: nTick,
      };
      state1.moves.push(newMove);
      conn.send(JSON.stringify(newMove));
    }
  });
  const tickLoop = setInterval(() => tick(state1), 550);

  var conn;
  var log = document.getElementById("log");

  function appendLog(item) {
    var doScroll = log.scrollTop > log.scrollHeight - log.clientHeight - 1;
    log.appendChild(item);
    if (doScroll) {
      log.scrollTop = log.scrollHeight - log.clientHeight;
    }
  }

  if (window["WebSocket"]) {
    conn = new WebSocket("ws://" + document.location.host + "/ws");
    conn.onclose = function (evt) {
      var item = document.createElement("div");
      item.innerHTML = "<b>Connection closed.</b>";
      appendLog(item);
    };
    conn.onmessage = function (evt) {
      var messages = evt.data.split("\n");
      for (var i = 0; i < messages.length; i++) {
        var item = document.createElement("div");
        item.innerText = messages[i];
        appendLog(item);
      }
    };
  } else {
    var item = document.createElement("div");
    item.innerHTML = "<b>Your browser does not support WebSockets.</b>";
    appendLog(item);
  }
</script>
